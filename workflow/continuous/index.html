<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Hakaru Team">
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Tutorial: Hakaru Workflow for Continuous Models - Hakaru</title>
        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/color-brewer.min.css">
        <link href="../../logo.css" rel="stylesheet">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="../..">Hakaru</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="../..">Home</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Introduction <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../intro/probprog/">What is Probabilistic Programming?</a>
</li>
                                    
<li >
    <a href="../../intro/installation/">Installing Hakaru</a>
</li>
                                    
<li >
    <a href="../../intro/samplegen/">Generating Samples from your Hakaru Program</a>
</li>
                                    
<li >
    <a href="../../intro/quickstart/">Quick Start: A Mixture Model Example</a>
</li>
                                    
<li >
    <a href="../../transforms/compile/">Compiling to Haskell</a>
</li>
                                    
<li >
    <a href="../../transforms/hkc/">Compiling to C</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Workflow and Examples <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../intro/">What is the Hakaru Workflow?</a>
</li>
                                    
<li >
    <a href="../discrete/">Tutorial: Hakaru Workflow for Discrete Models</a>
</li>
                                    
<li class="active">
    <a href="./">Tutorial: Hakaru Workflow for Continuous Models</a>
</li>
                                    
<li >
    <a href="../../examples/">Examples</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Language Guide <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../lang/rand/">Primitive Probability Distributions</a>
</li>
                                    
<li >
    <a href="../../lang/letbind/">Let and Bind</a>
</li>
                                    
<li >
    <a href="../../lang/cond/">Conditionals</a>
</li>
                                    
<li >
    <a href="../../lang/functions/">Functions</a>
</li>
                                    
<li >
    <a href="../../lang/coercions/">Types and Coercions</a>
</li>
                                    
<li >
    <a href="../../lang/datatypes/">Data Types and Match</a>
</li>
                                    
<li >
    <a href="../../lang/arrays/">Arrays and Plate</a>
</li>
                                    
<li >
    <a href="../../lang/loops/">Loops</a>
</li>
                                    
<li >
    <a href="../../transforms/expect/">Expect</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Transformations <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../transforms/normalize/">Normalize</a>
</li>
                                    
<li >
    <a href="../../transforms/disintegrate/">Disintegrate</a>
</li>
                                    
<li >
    <a href="../../transforms/density/">Density</a>
</li>
                                    
<li >
    <a href="../../transforms/hk-maple/">Hakaru Maple</a>
</li>
                                    
<li >
    <a href="../../transforms/mh/">Metropolis Hastings</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Internals <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../internals/ast/">AST and Hakaru Datakind</a>
</li>
                                    
<li >
    <a href="../../internals/abt/">ABT</a>
</li>
                                    
<li >
    <a href="../../internals/datums/">Datums</a>
</li>
                                    
<li >
    <a href="../../internals/coercions/">Coercions</a>
</li>
                                    
<li >
    <a href="../../internals/transforms/">Transformaitons</a>
</li>
                                    
<li >
    <a href="../../internals/testing/">Testing</a>
</li>
                                    
<li >
    <a href="../../internals/newfeature/">Adding a Language Feature</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li >
                                <a rel="next" href="../discrete/">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li >
                                <a rel="prev" href="../../examples/">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                            <li>
                                <a href="https://github.com/hakaru-dev/hakaru/edit/master/docs/workflow/continuous.md"><i class="fa fa-github"></i> Edit on GitHub</a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#tutorial-hakaru-workflow-for-a-continuous-model">Tutorial: Hakaru Workflow for a Continuous Model</a></li>
            <li><a href="#modelling">Modelling</a></li>
            <li><a href="#transformation">Transformation</a></li>
            <li><a href="#application">Application</a></li>
            <li><a href="#extra-a-syntactic-definition">Extra: A Syntactic Definition</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="tutorial-hakaru-workflow-for-a-continuous-model">Tutorial: Hakaru Workflow for a Continuous Model</h1>
<p>The real world is a complex and unpredictable place, so many statistical problems involve random real numbers. Hakaru is able to tackle
these real world problems using a similar approach to the one used for discrete models. To illustrate this workflow, the calibration of
thermometers is used<sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup>.</p>
<p>In this scenario, we are building thermometers that measure the temperature of a room. A reliable thermometer here relies on two
attributes:</p>
<ul>
<li>Temperature noise, or how much the room&rsquo;s temperature fluctuates over time</li>
<li>Measurement noise, or how often the thermometer measures the wrong value due to device defects</li>
</ul>
<p>In order to calibrate our thermometers, we want to approximate these values as accurately as possible so that our thermometers can 
tune its measurements based on its knowledge of temperature and measurement noise in the environment. </p>
<h2 id="modelling">Modelling</h2>
<p>For our thermometer model, we must first make a few assumptions about the environment. Normally this information would be collected as
part of the problem&rsquo;s domain knowledge. For this example, we will use the following information:</p>
<ul>
<li>The temperature noise follows a uniform distribution on the interval <script type="math/tex">[</script>3, 8<script type="math/tex">]</script>
</li>
<li>The measurement noise follows a uniform distribution with a range of <script type="math/tex">[</script>1, 4<script type="math/tex">]</script>
</li>
<li>Temperature and measurement samples follow a normal distribution</li>
<li>The initial temperature of the room is 21<script type="math/tex">^{\circ}</script>C</li>
</ul>
<p>Our model starts with the definition of the temperature and measurement noise. From our assumptions, we know that these values follow
a uniform distribution with real number intervals. In addition to defining distributions for these values, we will also use 
<a href="../../lang/coercions/">coercions</a> to cast the values from <code>real</code> to <code>prob</code> values:</p>
<pre><code class="nohighlight">nT &lt;~ uniform(3,8)
nM &lt;~ uniform(1,4)

noiseT = real2prob(nT)
noiseM = real2prob(nM)
</code></pre>

<p><strong>Note:</strong> See <a href="../../lang/letbind/">Let and Bind</a> for usage differences.</p>
<p>The values generated for <code>noiseT</code> and <code>noiseM</code> are used as the standard deviation required by the <a href="../../lang/rand/"><code>normal</code> primitive probability 
distribution</a> when generating values for temperature (<code>t1</code>, <code>t2</code>) and measurement (<code>m1</code>, <code>m2</code>).</p>
<p>For temperature, we need two values. The first is a temperature centered about the initial room temperature (21<script type="math/tex">^{\circ}</script>C) and the 
second is a future room temperature centered about the the first measured temperature. Both follow a normal distribution with a 
standard deviation of <code>noiseT</code>: </p>
<pre><code class="nohighlight">t1 &lt;~ normal(21, noiseT)
t2 &lt;~ normal(t1, noiseT)
</code></pre>

<p>Temperature measurements are centered about the temperature value being measured, therefore the values <code>t1</code> and <code>t2</code> are used. 
We made the initial assumption that measurement values follow a normal distribution, and we have generated <code>noiseM</code> as the standard
deviation:</p>
<pre><code class="nohighlight">m1 &lt;~ normal(t1, noiseM)
m2 &lt;~ normal(t2, noiseM)
</code></pre>

<p>Finally, we must return the information that we are interested in from our model. For measurement tuning, we are interested in the 
values of <code>m1</code> and <code>m2</code>. We would also like to know what kind of noise was generated in our model, <code>noiseT</code> and <code>noiseM</code>. We will
package these values together in related pairs. Instead of returning two seperate pairs of information, we will encapsulate the sets
into a container pair:</p>
<pre><code class="nohighlight">return ((m1, m2), (noiseT, noiseM))
</code></pre>

<p>The return statement completes our model definition. We have defined two values, <code>noiseT</code> and <code>noiseM</code>, to represent the environmental
noise in the temperature and measurement samples. We generated two room temperatures, <code>t1</code> and <code>t2</code>, which we used to generate the 
dependent measurement samples <code>m1</code> and <code>m2</code>. Once all the values have been generated, we return an information set containing the two
measurement samples and the environmental noise. With our completed model, we can use Hakaru program transformations to determine 
plausible thermometer calibration values.</p>
<h2 id="transformation">Transformation</h2>
<p>To calibrate our thermometers, we need to know how differences in environmental noises affect temperature measurements. For our scenario,
this means that we want to know what the conditional distribution on environmental noise given the measurement data. Unlike the <a href="../discrete/">discrete
model example</a>, this problem would be extremely difficult to reason about without transforming it in any way. </p>
<p>To generate a conditional distribution for this problem, we will use Hakaru&rsquo;s <a href="../../transforms/disintegrate/">disintegrate transform</a>.
This transformation requires that the target model have a <a href="../../lang/rand/">return statement</a> that presents information in the order of 
known information followed by unknown information. We have already configured our model in this manner, so we can run the <code>disintegrate</code>
transform immediately:</p>
<pre><code class="nohighlight">fn x8 pair(real, real):
match x8:
(x25, x26):
  nT &lt;~ uniform(+3/1, +8/1)
  nM &lt;~ uniform(+1/1, +4/1)
  noiseT = real2prob(nT)
  noiseM = real2prob(nM)
  t1 &lt;~ normal(+21/1, noiseT)
  t2 &lt;~ normal(t1, noiseT)
  x28 &lt;~ weight
           (exp((-(x25 - t1) ^ 2) / prob2real(2/1 * noiseM ^ 2))
            / noiseM
            / sqrt(2/1 * pi),
            return ())
  x27 &lt;~ weight
           (exp((-(x26 - t2) ^ 2) / prob2real(2/1 * noiseM ^ 2))
            / noiseM
            / sqrt(2/1 * pi),
            return ())
  return (noiseT, noiseM)
_: reject. measure(pair(prob, prob))
</code></pre>

<p>An additional Hakaru transformation that can be performed at this stage is
the <a href="../../transforms/hk-maple/">Hakaru-Maple <code>simplify</code> subcommand</a>. This will
call Maple to algebraically simplify Hakaru models. The result is a more
efficient program, sampling from two <code>uniform</code> distributions instead of four.</p>
<pre><code class="nohighlight">fn x8 pair(real, real):
match x8:
(r3, r1):
  weight
    (1/ pi * (1/2),
     nTd &lt;~ uniform(+3/1, +8/1)
     nMb &lt;~ uniform(+1/1, +4/1)
     weight
       (exp
          ((nMb ^ 2 * r1 ^ 2
            + nMb ^ 2 * r3 ^ 2
            + nTd ^ 2 * r1 ^ 2
            + nTd ^ 2 * r1 * r3 * (-2/1)
            + nTd ^ 2 * r3 ^ 2 * (+2/1)
            + nMb ^ 2 * r1 * (-42/1)
            + r3 * nMb ^ 2 * (-42/1)
            + r3 * nTd ^ 2 * (-42/1)
            + nMb ^ 2 * (+882/1)
            + nTd ^ 2 * (+441/1))
           / (nMb ^ 4 + nTd ^ 2 * nMb ^ 2 * (+3/1) + nTd ^ 4)
           * (-1/2))
        / sqrt(real2prob(nMb ^ 4 + nTd ^ 2 * nMb ^ 2 * (+3/1) + nTd ^ 4)),
        return (real2prob(nTd), real2prob(nMb))))
</code></pre>

<p>The two models are equivalent, so you must decide which model that you want to use for your application. For the purposes of this tutorial, we will use the
unsimplified version of the model (<code>thermometer_disintegrate.hk</code>).</p>
<p>Our thermometer model is two dimensional, so it is possible for us to tune our model values using importance sampling or an exhaustive search. However, these approaches
will not be possible in higher dimensions. Therefore, we will use a <em>Markov Chain Monte Carlo</em> method called <em>Metropolis-Hastings</em> to demonstrate how Hakaru can be used 
for problems with high dimensionality. To use the <a href="../../transforms/mh/">Metropolis-Hastings transform</a>, you must have a target distribution and a transition kernel. The 
thermometer model that we have already built will be our target distribution, but we have yet to create the transition kernel.</p>
<p>When specifying a model to be the transition kernel, our goal is to propose samples that are representative of the posterior model. For this example, we will hold one of 
the noise parameters constant will updating the other by drawing new values from a <code>uniform</code> distribution. This allows the sampler to remember a good setting for a parameter
when one is found, allowing it to concentrate on the remaining parameters:</p>
<pre><code class="nohighlight">fn noise pair(prob, prob):
          match noise:
           (noiseTprev, noiseMprev):
            weight(1/2, 
                    noiseTprime &lt;~ uniform(3,8)
                    return (real2prob(noiseTprime), noiseMprev)) &lt;|&gt;
            weight(1/2, 
                   noiseMprime &lt;~ uniform(1,4)
                   return (noiseTprev, real2prob(noiseMprime)))
</code></pre>

<p><strong>Note: </strong>Like any model in Hakaru, this program can be passed to other program transformations such as <code>hk-maple</code>. </p>
<h2 id="application">Application</h2>
<p>With both our target distribution and transition kernel defined, we can now use the Metropolis-Hastings method to transform our program. However, instead of calling <code>mh</code> in
the command prompt, we will include it as part of our Hakaru program by using the <code>mcmc(&lt;kernel&gt;, &lt;target&gt;)</code> syntactic transform:</p>
<pre><code class="nohighlight">    mcmc(
        simplify(
        fn noise pair(prob, prob):
          match noise:
           (noiseTprev, noiseMprev):
            weight(1/2, 
                    noiseTprime &lt;~ uniform(3,8)
                    return (real2prob(noiseTprime), noiseMprev)) &lt;|&gt;
            weight(1/2, 
                   noiseMprime &lt;~ uniform(1,4)
                   return (noiseTprev, real2prob(noiseMprime))))
          ,
          simplify(
          fn x8 pair(real, real):
            match x8:
            (r3, r1):
              weight
                (1/ pi * (1/2),
                 nTd &lt;~ uniform(+3/1, +8/1)
                 nMb &lt;~ uniform(+1/1, +4/1)
                 weight
                   (exp
                      ((nMb ^ 2 * r1 ^ 2
                        + nMb ^ 2 * r3 ^ 2
                        + nTd ^ 2 * r1 ^ 2
                        + nTd ^ 2 * r1 * r3 * (-2/1)
                        + nTd ^ 2 * r3 ^ 2 * (+2/1)
                        + nMb ^ 2 * r1 * (-42/1)
                        + r3 * nMb ^ 2 * (-42/1)
                        + r3 * nTd ^ 2 * (-42/1)
                        + nMb ^ 2 * (+882/1)
                        + nTd ^ 2 * (+441/1))
                       / (nMb ^ 4 + nTd ^ 2 * nMb ^ 2 * (+3/1) + nTd ^ 4)
                       * (-1/2))
                    / sqrt(real2prob(nMb ^ 4 + nTd ^ 2 * nMb ^ 2 * (+3/1) + nTd ^ 4)),
                    return (real2prob(nTd), real2prob(nMb)))))
      )
</code></pre>

<p><strong>Note:</strong> Each model within the <code>mcmc</code> syntax must be wrapped within another syntactic transform. For this example, we are using the <code>simplify</code> transform.</p>
<p>The <code>mcmc</code> syntactic transform must also be wrapped in a Hakaru function that has the same type signature as the target model. Due to the self-referential nature of MCMC
methods, this function is referenced at the end of the target model&rsquo;s definition. We will call this function <code>recurse</code>:</p>
<pre><code class="nohighlight">fn recurse pair(real, real):
    mcmc(
        simplify(
        fn noise pair(prob, prob):
          match noise:
           (noiseTprev, noiseMprev):
            weight(1/2, 
                    noiseTprime &lt;~ uniform(3,8)
                    return (real2prob(noiseTprime), noiseMprev)) &lt;|&gt;
            weight(1/2, 
                   noiseMprime &lt;~ uniform(1,4)
                   return (noiseTprev, real2prob(noiseMprime))))
          ,
          simplify(
          fn x8 pair(real, real):
            match x8:
            (r3, r1):
              weight
                (1/ pi * (1/2),
                 nTd &lt;~ uniform(+3/1, +8/1)
                 nMb &lt;~ uniform(+1/1, +4/1)
                 weight
                   (exp
                      ((nMb ^ 2 * r1 ^ 2
                        + nMb ^ 2 * r3 ^ 2
                        + nTd ^ 2 * r1 ^ 2
                        + nTd ^ 2 * r1 * r3 * (-2/1)
                        + nTd ^ 2 * r3 ^ 2 * (+2/1)
                        + nMb ^ 2 * r1 * (-42/1)
                        + r3 * nMb ^ 2 * (-42/1)
                        + r3 * nTd ^ 2 * (-42/1)
                        + nMb ^ 2 * (+882/1)
                        + nTd ^ 2 * (+441/1))
                       / (nMb ^ 4 + nTd ^ 2 * nMb ^ 2 * (+3/1) + nTd ^ 4)
                       * (-1/2))
                    / sqrt(real2prob(nMb ^ 4 + nTd ^ 2 * nMb ^ 2 * (+3/1) + nTd ^ 4)),
                    return (real2prob(nTd), real2prob(nMb)))))(recurse)
      )
</code></pre>

<p>Our MCMC transform is now defined and ready to be processed. To convert this model into a form understood by the <code>hakaru</code> command, you must run the <code>hk-maple</code> transform:</p>
<pre><code class="bash">$ hk-maple examples/documentation/thermometer_mcmc.hk
fn recurse pair(real, real):
x5 = x17 = fn x16 pair(prob, prob):
           1/1
           * (1/1)
           * (match x16:
              (x35, x36):
                x37 = prob2real(x35)
                x38 = prob2real(x36)
                match recurse:
                (r3, r1):
                  1/ pi
                  * (1/2)
                  * (match +3/1 &lt;= x37 &amp;&amp; x37 &lt;= +8/1:
                     true:
                       1/ real2prob(+8/1 - (+3/1))
                       * (nTdd = prob2real(x35)
                          match +1/1 &lt;= x38 &amp;&amp; x38 &lt;= +4/1:
                          true:
                            1/ real2prob(+4/1 - (+1/1))
                            * (x44 = ()
                               nMbb = prob2real(x36)
                               exp
                                 ((nMbb ^ 2 * r1 ^ 2
                                   + nMbb ^ 2 * r3 ^ 2
                                   + nTdd ^ 2 * r1 ^ 2
                                   + nTdd ^ 2 * r1 * r3 * (-2/1)
                                   + nTdd ^ 2 * r3 ^ 2 * (+2/1)
                                   + nMbb ^ 2 * r1 * (-42/1)
                                   + nMbb ^ 2 * r3 * (-42/1)
                                   + nTdd ^ 2 * r3 * (-42/1)
                                   + nMbb ^ 2 * (+882/1)
                                   + nTdd ^ 2 * (+441/1))
                                  / (nMbb ^ 4 + nMbb ^ 2 * nTdd ^ 2 * (+3/1) + nTdd ^ 4)
                                  * (-1/2))
                               / sqrt
                                   (real2prob(nMbb ^ 4 + nMbb ^ 2 * nTdd ^ 2 * (+3/1) + nTdd ^ 4))
                               * (1/1))
                          _: 0/1)
                     _: 0/1)
                _: 0/1
              _: 0/1)
     fn x16 pair(prob, prob):
     x0 &lt;~ (fn noise pair(prob, prob):
            match noise:
            (r3, r1):
              weight
                (1/2,
                 noiseTprime7 &lt;~ uniform(+3/1, +8/1)
                 return (real2prob(noiseTprime7), r1)) &lt;|&gt;
              weight
                (1/2,
                 noiseMprime9 &lt;~ uniform(+1/1, +4/1)
                 return (r3, real2prob(noiseMprime9))))
             (x16)
     return (x0, x17(x0) / x17(x16))
fn x4 pair(prob, prob):
x3 &lt;~ x5(x4)
match x3:
(x1, x2):
  x0 &lt;~ x0 &lt;~ categorical
                ([min(1/1, x2),
                  real2prob(prob2real(1/1) - prob2real(min(1/1, x2)))])
        return [true, false][x0]
  return if x0: x1 else: x4
</code></pre>

<p><strong>Note:</strong> You can run the <code>hk-maple</code> function on the resulting program to 
<a href="https://github.com/hakaru-dev/hakaru/blob/master/examples/documentation/thermometer_mcmc_processed.hk">simplify it</a>.</p>
<p>With our model defined and processed, we can now assign it values to generate samples from. For the sake of this example, let&rsquo;s say that we observed temperature measurements
of 29<script type="math/tex">^{\circ}</script>C and 26<script type="math/tex">^{\circ}</script>C. To use these values, we must turn our anonymous Hakaru functions into callable ones so that we can assign them the pair (29,26). For
our transition kernel (<a href="https://github.com/hakaru-dev/hakaru/blob/master/examples/documentation/thermometer_mcmc_processed.hk">thermometer_mcmc_processed.hk</a>), this change 
would be:</p>
<pre><code class="nohighlight">therm = fn recurse pair(real, real):
 match recurse:
 ...
           return (rf, rd)))
therm((29,26))
</code></pre>

<p><strong>Note:</strong> This is the simplified version of our transition kernel. Due to its length, this program has been shortened to make the changes more apparent.</p>
<p>After the same change, our target Hakru program (<a href="https://github.com/hakaru-dev/hakaru/blob/master/examples/documentation/thermometer_disintegrate_simplify.hk">thermometer_disintegrate_simplify.hk</a>)
becomes:</p>
<pre><code class="nohighlight">thermometer = fn x8 pair(real, real):
 match x8:
 (r3, r1):
  weight
    (1/ pi * (1/2),
     nTd &lt;~ uniform(+3/1, +8/1)
     nMb &lt;~ uniform(+1/1, +4/1)
     weight
       (exp
          ((nMb ^ 2 * r1 ^ 2
            + nMb ^ 2 * r3 ^ 2
            + nTd ^ 2 * r1 ^ 2
            + nTd ^ 2 * r1 * r3 * (-2/1)
            + nTd ^ 2 * r3 ^ 2 * (+2/1)
            + nMb ^ 2 * r1 * (-42/1)
            + r3 * nMb ^ 2 * (-42/1)
            + r3 * nTd ^ 2 * (-42/1)
            + nMb ^ 2 * (+882/1)
            + nTd ^ 2 * (+441/1))
           / (nMb ^ 4 + nTd ^ 2 * nMb ^ 2 * (+3/1) + nTd ^ 4)
           * (-1/2))
        / sqrt(real2prob(nMb ^ 4 + nTd ^ 2 * nMb ^ 2 * (+3/1) + nTd ^ 4)),
        return (real2prob(nTd), real2prob(nMb))))
thermometer((29,26))
</code></pre>

<p>With these alterations, we can finally use the <code>hakaru</code> command to generate samples from our model:</p>
<pre><code class="bash">$ hakaru --transition-kernel thermometer_mcmc_processed.hk thermometer_disintegrate_simplify.hk
(3.1995679303602578, 2.3093879567135325)
(3.1995679303602578, 2.3093879567135325)
(3.1995679303602578, 3.664010086898677)
(3.1995679303602578, 3.664010086898677)
(3.512655151270474, 3.664010086898677)
(6.535434584595698, 3.664010086898677)
(7.944581473529944, 3.664010086898677)
(6.960163985266382, 3.664010086898677)
(6.960163985266382, 1.850724571692917)
(6.960163985266382, 1.850724571692917)
(6.960163985266382, 1.850724571692917)
...
</code></pre>

<p>In the Hakaru system definition paper<sup id="fnref2:1"><a class="footnote-ref" href="#fn:1">1</a></sup>, a graph is generated from the data by collecting every fifth sample from 20,000 generated 
samples. You can create a file with this information by using an <code>awk</code> script, which can then be imported into a graphing software
package such as Maple:</p>
<pre><code class="bash">$ hakaru --transition-kernel thermometer_mcmc_processed.hk thermometer_disintegrate_simplify.hk | head -n 20000 | awk 'BEGIN{i = 0}{if (i % 5 == 0) a[i/5] = $0; i = i + 1}END{for (j in a) print a[j]}' &gt; thermometer_output.txt
</code></pre>

<h2 id="extra-a-syntactic-definition">Extra: A Syntactic Definition</h2>
<p>This tutorial demonstrates how both command line and syntactic Hakaru transforms can be used in the same problem. This might not always be necessary because you might be able
to use only command line or only syntactic Hakaru transforms. For example, the thermometer model can be expressed 
<a href="https://github.com/hakaru-dev/hakaru/blob/master/examples/documentation/thermometer_workflow.hk">using only syntactic transforms</a>:</p>
<pre><code class="nohighlight">simplify(
  fn x pair(real, real):
    mcmc(
      simplify(
        fn noise pair(prob, prob):
          match noise:
           (noiseTprev, noiseMprev):
            weight(1/2, 
                    noiseTprime &lt;~ uniform(3,8)
                    return (real2prob(noiseTprime), noiseMprev)) &lt;|&gt;
            weight(1/2, 
                   noiseMprime &lt;~ uniform(1,4)
                   return (noiseTprev, real2prob(noiseMprime))))
      ,
      simplify(
        disint(
          nT &lt;~ uniform(3,8)
          nM &lt;~ uniform(1,4)

          noiseT = real2prob(nT)
          noiseM = real2prob(nM)

          t1 &lt;~ normal(21, noiseT)
          t2 &lt;~ normal(t1, noiseT)

          m1 &lt;~ normal(t1, noiseM)
          m2 &lt;~ normal(t2, noiseM)

          return ((m1, m2), (noiseT, noiseM))))(x)
      )
)
</code></pre>

<p>This Hakaru program will produce <a href="https://github.com/hakaru-dev/hakaru/blob/master/examples/documentation/thermometer_workflow_res.hk">the same output program</a> as the 
mixed-usage example when evaluated using <code>hk-maple</code>.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>P. Narayanan, J. Carette, W. Romano, C. Shan and R. Zinkov, &ldquo;Probabilistic Inference by Program Transformation in Hakaru (System Description)&rdquo;, Functional and Logic 
Programming, pp. 62-79, 2016.&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../js/mathjaxhelper.js" defer></script>
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
