<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Hakaru Team">
        
        <link rel="shortcut icon" href="favicon.ico">
        

	<title>AST and Hakaru Datakind - Hakaru</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="../../logo.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Hakaru</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="../..">Home</a>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Introduction <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
<li >
    <a href="../../intro/probprog/">What is Probabilistic Programming?</a>
</li>

                    
                        
<li >
    <a href="../../intro/installation/">Installing Hakaru</a>
</li>

                    
                        
<li >
    <a href="../../intro/quickstart/">Quick Start: A Mixture Model Example</a>
</li>

                    
                        
<li >
    <a href="../../examples/">Examples</a>
</li>

                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Language Guide <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
<li >
    <a href="../../lang/rand/">Primitive Probability Distributions</a>
</li>

                    
                        
<li >
    <a href="../../lang/letbind/">Let and Bind</a>
</li>

                    
                        
<li >
    <a href="../../lang/cond/">Conditionals</a>
</li>

                    
                        
<li >
    <a href="../../lang/functions/">Functions</a>
</li>

                    
                        
<li >
    <a href="../../lang/coercions/">Types and Coercions</a>
</li>

                    
                        
<li >
    <a href="../../lang/datatypes/">Data Types and Match</a>
</li>

                    
                        
<li >
    <a href="../../lang/arrays/">Arrays and Plate</a>
</li>

                    
                        
<li >
    <a href="../../lang/loops/">Loops</a>
</li>

                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Transformations <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
<li >
    <a href="../../transforms/expect/">Expect and Normalize</a>
</li>

                    
                        
<li >
    <a href="../../transforms/disintegrate/">Disintegrate and Density</a>
</li>

                    
                        
<li >
    <a href="../../transforms/simplify/">Simplify</a>
</li>

                    
                        
<li >
    <a href="../../transforms/mh/">Metropolis Hastings</a>
</li>

                    
                        
<li >
    <a href="../../transforms/compile/">Compiling to Haskell</a>
</li>

                    
                        
<li >
    <a href="../../transforms/hkc/">Compiling to C</a>
</li>

                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Internals <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
<li class="active">
    <a href="./">AST and Hakaru Datakind</a>
</li>

                    
                        
<li >
    <a href="../abt/">ABT</a>
</li>

                    
                        
<li >
    <a href="../datums/">Datums</a>
</li>

                    
                        
<li >
    <a href="../coercions/">Coercions</a>
</li>

                    
                        
<li >
    <a href="../transforms/">Transformaitons</a>
</li>

                    
                        
<li >
    <a href="../testing/">Testing</a>
</li>

                    
                        
<li >
    <a href="../newfeature/">Adding a Language Feature</a>
</li>

                    
                    </ul>
                </li>
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                <li >
                    <a rel="next" href="../../transforms/hkc/">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </li>
                <li >
                    <a rel="prev" href="../abt/">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
                <li>
                    <a href="https://github.com/hakaru-dev/hakaru">
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#internal-representation-of-hakaru-terms">Internal Representation of Hakaru terms</a></li>
        
            <li><a href="#datakind">Datakind</a></li>
        
            <li><a href="#term">Term</a></li>
        
            <li><a href="#scons-and-sargs">SCons and SArgs</a></li>
        
            <li><a href="#measureop">MeasureOp</a></li>
        
            <li><a href="#arrayop">ArrayOp</a></li>
        
            <li><a href="#primop">PrimOp</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<h1 id="internal-representation-of-hakaru-terms">Internal Representation of Hakaru terms</h1>
<p>The Hakaru AST can be found defined in
<a href="https://github.com/hakaru-dev/hakaru/blob/master/haskell/Language/Hakaru/Syntax/AST.hs">haskell/Language/Hakaru/Syntax/AST.hs</a>. It is made up of several parts which this section and the next one will explain.</p>
<p>We should note, this datatype makes use of
<a href="http://winterkoninkje.dreamwidth.org/103978.html">Abstract Binding Trees</a>
which we discuss in more detail in the next
<a href="../../internals/abt">section</a>. ABTs can be understood as a way to abstract
the use of variables in the AST. The advantage of this is it allows
all variable substitution and manipulation logic to live in one place
and not be specific to a particular AST.</p>
<h2 id="datakind">Datakind</h2>
<p>The AST is typed using the Hakaru kind, defined in <a href="https://github.com/hakaru-dev/hakaru/blob/master/haskell/Language/Hakaru/Types/DataKind.hs">haskell/Language/Types/DataKind.hs</a>. All Hakaru types are defined in terms of
the primitives in this datakind.</p>
<pre><code class="haskell">-- | The universe\/kind of Hakaru types.
data Hakaru
    = HNat -- ^ The natural numbers; aka, the non-negative integers.

    -- | The integers.
    | HInt

    -- | Non-negative real numbers. Unlike what you might expect,
    -- this is /not/ restructed to the @[0,1]@ interval!
    | HProb

    -- | The affinely extended real number line. That is, the real
    -- numbers extended with positive and negative infinities.
    | HReal

    -- | The measure monad
    | HMeasure !Hakaru

    -- | The built-in type for uniform arrays.
    | HArray !Hakaru

    -- | The type of Hakaru functions.
    | !Hakaru :-&gt; !Hakaru

    -- | A user-defined polynomial datatype. Each such type is
    -- specified by a \&quot;tag\&quot; (the @HakaruCon@) which names the type, and a sum-of-product representation of the type itself.
    | HData !HakaruCon [[HakaruFun]]

</code></pre>

<p>Please read Datakind.hs for more details.</p>
<h2 id="term">Term</h2>
<p>The Term datatype includes all the syntactic constructions for the Hakaru language.
For all those where we know the number of arguments we expect that language construct
to get, we define the <code>(:$)</code> constructor, which takes <code>SCons</code> and <code>SArgs</code> datatypes
as arguments.</p>
<pre><code class="haskell">-- | The generating functor for Hakaru ASTs. This type is given in
-- open-recursive form, where the first type argument gives the
-- recursive form. The recursive form @abt@ does not have exactly
-- the same kind as @Term abt@ because every 'Term' represents a
-- locally-closed term whereas the underlying @abt@ may bind some
-- variables.
data Term :: ([Hakaru] -&gt; Hakaru -&gt; *) -&gt; Hakaru -&gt; * where
    -- Simple syntactic forms (i.e., generalized quantifiers)
    (:$) :: !(SCon args a) -&gt; !(SArgs abt args) -&gt; Term abt a

    -- N-ary operators
    NaryOp_ :: !(NaryOp a) -&gt; !(Seq (abt '[] a)) -&gt; Term abt a

    -- Literal\/Constant values
    Literal_ :: !(Literal a) -&gt; Term abt a

    Empty_ :: !(Sing ('HArray a)) -&gt; Term abt ('HArray a)
    Array_
        :: !(abt '[] 'HNat)
        -&gt; !(abt '[ 'HNat ] a)
        -&gt; Term abt ('HArray a)

    -- -- User-defined data types
    -- A data constructor applied to some expressions. N.B., this
    -- definition only accounts for data constructors which are
    -- fully saturated. Unsaturated constructors will need to be
    -- eta-expanded.
    Datum_ :: !(Datum (abt '[]) (HData' t)) -&gt; Term abt (HData' t)

    -- Generic case-analysis (via ABTs and Structural Focalization).
    Case_ :: !(abt '[] a) -&gt; [Branch a abt b] -&gt; Term abt b

    -- Linear combinations of measures.
    Superpose_
        :: L.NonEmpty (abt '[] 'HProb, abt '[] ('HMeasure a))
        -&gt; Term abt ('HMeasure a)

    Reject_ :: !(Sing ('HMeasure a)) -&gt; Term abt ('HMeasure a)
</code></pre>

<h2 id="scons-and-sargs">SCons and SArgs</h2>
<p>When using <code>(:$)</code> we have a way to describe primitives where we
know the number of arguments they should get. In that regard,
SArgs is a typed list of abt terms indexed by its size.</p>
<pre><code class="haskell">-- | The arguments to a @(':$')@ node in the 'Term'; that is, a list
-- of ASTs, where the whole list is indexed by a (type-level) list
-- of the indices of each element.
data SArgs :: ([Hakaru] -&gt; Hakaru -&gt; *) -&gt; [([Hakaru], Hakaru)] -&gt; *
    where
    End :: SArgs abt '[]
    (:*) :: !(abt vars a)
        -&gt; !(SArgs abt args)
        -&gt; SArgs abt ( '(vars, a) ': args)
</code></pre>

<p>These are combined with SCons which describes the constructor, and
the types it expects for its arguments. For example suppose we had
an AST for a function <code>f</code> and it&rsquo;s argument <code>x</code>, we could construct
a Term for applying <code>f</code> to <code>x</code> by writing <code>App_:$ f :* x :* End</code>.</p>
<pre><code class="haskell">-- | The constructor of a @(':$')@ node in the 'Term'. Each of these
-- constructors denotes a \&quot;normal\/standard\/basic\&quot; syntactic
-- form (i.e., a generalized quantifier). In the literature, these
-- syntactic forms are sometimes called \&quot;operators\&quot;, but we avoid
-- calling them that so as not to introduce confusion vs 'PrimOp'
-- etc. Instead we use the term \&quot;operator\&quot; to refer to any primitive
-- function or constant; that is, non-binding syntactic forms. Also
-- in the literature, the 'SCon' type itself is usually called the
-- \&quot;signature\&quot; of the term language. However, we avoid calling
-- it that since our 'Term' has constructors other than just @(:$)@,
-- so 'SCon' does not give a complete signature for our terms.
--
-- The main reason for breaking this type out and using it in
-- conjunction with @(':$')@ and 'SArgs' is so that we can easily
-- pattern match on /fully saturated/ nodes. For example, we want
-- to be able to match @MeasureOp_ Uniform :$ lo :* hi :* End@
-- without needing to deal with 'App_' nodes nor 'viewABT'.
data SCon :: [([Hakaru], Hakaru)] -&gt; Hakaru -&gt; * where
    Lam_ :: SCon '[ '( '[ a ], b ) ] (a ':-&gt; b)
    App_ :: SCon '[ LC (a ':-&gt; b ), LC a ] b
    Let_ :: SCon '[ LC a, '( '[ a ], b ) ] b

    CoerceTo_   :: !(Coercion a b) -&gt; SCon '[ LC a ] b
    UnsafeFrom_ :: !(Coercion a b) -&gt; SCon '[ LC b ] a

    PrimOp_
        :: (typs ~ UnLCs args, args ~ LCs typs)
        =&gt; !(PrimOp typs a) -&gt; SCon args a
    ArrayOp_
        :: (typs ~ UnLCs args, args ~ LCs typs)
        =&gt; !(ArrayOp typs a) -&gt; SCon args a
    MeasureOp_
        :: (typs ~ UnLCs args, args ~ LCs typs)
        =&gt; !(MeasureOp typs a) -&gt; SCon args ('HMeasure a)

    Dirac :: SCon '[ LC a ] ('HMeasure a)

    MBind :: SCon
        '[ LC ('HMeasure a)
        ,  '( '[ a ], 'HMeasure b)
        ] ('HMeasure b)

    Plate :: SCon
        '[ LC 'HNat
        , '( '[ 'HNat ], 'HMeasure a)
        ] ('HMeasure ('HArray a))

    Chain :: SCon
        '[ LC 'HNat, LC s
        , '( '[ s ],  'HMeasure (HPair a s))
        ] ('HMeasure (HPair ('HArray a) s))

    Integrate
        :: SCon '[ LC 'HReal, LC 'HReal, '( '[ 'HReal ], 'HProb) ] 'HProb

    Summate
        :: HDiscrete a
        -&gt; HSemiring b
        -&gt; SCon '[ LC a, LC a, '( '[ a ], b) ] b

    Product
        :: HDiscrete a
        -&gt; HSemiring b
        -&gt; SCon '[ LC a, LC a, '( '[ a ], b) ] b

    Expect :: SCon '[ LC ('HMeasure a), '( '[ a ], 'HProb) ] 'HProb

    Observe :: SCon '[ LC ('HMeasure a), LC a ] ('HMeasure a)
</code></pre>

<p>You&rsquo;ll notice in <code>SCon</code> there are definitions for PrimOp, MeasureOp, and ArrayOp
these are done more organizational purposes and have constructions for the
different categories of primitives.</p>
<h2 id="measureop">MeasureOp</h2>
<p>Primitives of type measure are defined in MeasureOp.</p>
<pre><code class="haskell">-- | Primitive operators to produce, consume, or transform
-- distributions\/measures. This corresponds to the old @Mochastic@
-- class, except that 'MBind' and 'Superpose_' are handled elsewhere
-- since they are not simple operators. (Also 'Dirac' is handled
-- elsewhere since it naturally fits with 'MBind', even though it
-- is a siple operator.)
data MeasureOp :: [Hakaru] -&gt; Hakaru -&gt; * where
    Lebesgue    :: MeasureOp '[]                 'HReal
    Counting    :: MeasureOp '[]                 'HInt
    Categorical :: MeasureOp '[ 'HArray 'HProb ] 'HNat
    Uniform     :: MeasureOp '[ 'HReal, 'HReal ] 'HReal
    Normal      :: MeasureOp '[ 'HReal, 'HProb ] 'HReal
    Poisson     :: MeasureOp '[ 'HProb         ] 'HNat
    Gamma       :: MeasureOp '[ 'HProb, 'HProb ] 'HProb
    Beta        :: MeasureOp '[ 'HProb, 'HProb ] 'HProb
</code></pre>

<h2 id="arrayop">ArrayOp</h2>
<p>Primitives that involve manipulating value of type array,
end up in ArrayOp.</p>
<pre><code class="haskell">-- | Primitive operators for consuming or transforming arrays.
data ArrayOp :: [Hakaru] -&gt; Hakaru -&gt; * where
    Index  :: !(Sing a) -&gt; ArrayOp '[ 'HArray a, 'HNat ] a
    Size   :: !(Sing a) -&gt; ArrayOp '[ 'HArray a ] 'HNat
    Reduce :: !(Sing a) -&gt; ArrayOp '[ a ':-&gt; a ':-&gt; a, a, 'HArray a ] a
</code></pre>

<h2 id="primop">PrimOp</h2>
<p>All primitive operations which don&rsquo;t return something
of type array or measure are placed in PrimOp</p>
<pre><code class="haskell">-- | Simple primitive functions, and constants.
data PrimOp :: [Hakaru] -&gt; Hakaru -&gt; * where

    -- -- -- Here we have /monomorphic/ operators
    -- -- The Boolean operators
    Not  :: PrimOp '[ HBool ] HBool
    -- And, Or, Xor, Iff
    Impl :: PrimOp '[ HBool, HBool ] HBool
    -- Impl x y == Or (Not x) y
    Diff :: PrimOp '[ HBool, HBool ] HBool
    -- Diff x y == Not (Impl x y)
    Nand :: PrimOp '[ HBool, HBool ] HBool
    -- Nand aka Alternative Denial, Sheffer stroke
    Nor  :: PrimOp '[ HBool, HBool ] HBool
    -- Nor aka Joint Denial, aka Quine dagger, aka Pierce arrow

    -- -- Trigonometry operators
    Pi    :: PrimOp '[] 'HProb
    Sin   :: PrimOp '[ 'HReal ] 'HReal
    Cos   :: PrimOp '[ 'HReal ] 'HReal
    Tan   :: PrimOp '[ 'HReal ] 'HReal
    Asin  :: PrimOp '[ 'HReal ] 'HReal
    Acos  :: PrimOp '[ 'HReal ] 'HReal
    Atan  :: PrimOp '[ 'HReal ] 'HReal
    Sinh  :: PrimOp '[ 'HReal ] 'HReal
    Cosh  :: PrimOp '[ 'HReal ] 'HReal
    Tanh  :: PrimOp '[ 'HReal ] 'HReal
    Asinh :: PrimOp '[ 'HReal ] 'HReal
    Acosh :: PrimOp '[ 'HReal ] 'HReal
    Atanh :: PrimOp '[ 'HReal ] 'HReal

    -- -- Other Real\/Prob-valued operators
    RealPow   :: PrimOp '[ 'HProb, 'HReal ] 'HProb
    Exp       :: PrimOp '[ 'HReal ] 'HProb
    Log       :: PrimOp '[ 'HProb ] 'HReal
    Infinity  :: HIntegrable a -&gt; PrimOp '[] a
    GammaFunc :: PrimOp '[ 'HReal ] 'HProb
    BetaFunc  :: PrimOp '[ 'HProb, 'HProb ] 'HProb

    -- -- -- Here we have the /polymorphic/ operators
    -- -- HEq and HOrd operators
    Equal :: !(HEq  a) -&gt; PrimOp '[ a, a ] HBool
    Less  :: !(HOrd a) -&gt; PrimOp '[ a, a ] HBool

    -- -- HSemiring operators (the non-n-ary ones)
    NatPow :: !(HSemiring a) -&gt; PrimOp '[ a, 'HNat ] a

    -- -- HRing operators
    Negate :: !(HRing a) -&gt; PrimOp '[ a ] a
    Abs    :: !(HRing a) -&gt; PrimOp '[ a ] (NonNegative a)
    Signum :: !(HRing a) -&gt; PrimOp '[ a ] a

    -- -- HFractional operators
    Recip :: !(HFractional a) -&gt; PrimOp '[ a ] a

    -- -- HRadical operators
    NatRoot :: !(HRadical a) -&gt; PrimOp '[ a, 'HNat ] a

    -- -- HContinuous operators
    Erf :: !(HContinuous a) -&gt; PrimOp '[ a ] a
</code></pre></div>
        </div>

        <footer class="col-md-12">
            <hr>
            
            <center>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</center>
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script>var base_url = '../..';</script>
        <script data-main="../../mkdocs/js/search.js" src="../../mkdocs/js/require.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../js/mathjaxhelper.js"></script>
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                        <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            From here you can search these documents. Enter
                            your search terms below.
                        </p>
                        <form role="form">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                            </div>
                        </form>
                        <div id="mkdocs-search-results"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>
    </body>
</html>