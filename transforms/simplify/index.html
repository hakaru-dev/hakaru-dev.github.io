<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Hakaru Team">
        
        <link rel="shortcut icon" href="favicon.ico">
        

	<title>Simplify - Hakaru</title>

        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../css/base.css" rel="stylesheet">
        <link href="../../logo.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../..">Hakaru</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="../..">Home</a>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Introduction <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
<li >
    <a href="../../intro/probprog/">What is Probabilistic Programming?</a>
</li>

                    
                        
<li >
    <a href="../../intro/installation/">Installing Hakaru</a>
</li>

                    
                        
<li >
    <a href="../../intro/samplegen/">Generating Samples from your Hakaru Program</a>
</li>

                    
                        
<li >
    <a href="../../intro/quickstart/">Quick Start: A Mixture Model Example</a>
</li>

                    
                        
<li >
    <a href="../../examples/">Examples</a>
</li>

                    
                        
<li >
    <a href="../compile/">Compiling to Haskell</a>
</li>

                    
                        
<li >
    <a href="../hkc/">Compiling to C</a>
</li>

                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Language Guide <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
<li >
    <a href="../../lang/rand/">Primitive Probability Distributions</a>
</li>

                    
                        
<li >
    <a href="../../lang/letbind/">Let and Bind</a>
</li>

                    
                        
<li >
    <a href="../../lang/cond/">Conditionals</a>
</li>

                    
                        
<li >
    <a href="../../lang/functions/">Functions</a>
</li>

                    
                        
<li >
    <a href="../../lang/coercions/">Types and Coercions</a>
</li>

                    
                        
<li >
    <a href="../../lang/datatypes/">Data Types and Match</a>
</li>

                    
                        
<li >
    <a href="../../lang/arrays/">Arrays and Plate</a>
</li>

                    
                        
<li >
    <a href="../../lang/loops/">Loops</a>
</li>

                    
                        
<li >
    <a href="../expect/">Expect</a>
</li>

                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Transformations <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
<li >
    <a href="../normalize/">Normalize</a>
</li>

                    
                        
<li >
    <a href="../disintegrate/">Disintegrate</a>
</li>

                    
                        
<li >
    <a href="../density/">Density</a>
</li>

                    
                        
<li class="active">
    <a href="./">Simplify</a>
</li>

                    
                        
<li >
    <a href="../mh/">Metropolis Hastings</a>
</li>

                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Internals <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
<li >
    <a href="../../internals/ast/">AST and Hakaru Datakind</a>
</li>

                    
                        
<li >
    <a href="../../internals/abt/">ABT</a>
</li>

                    
                        
<li >
    <a href="../../internals/datums/">Datums</a>
</li>

                    
                        
<li >
    <a href="../../internals/coercions/">Coercions</a>
</li>

                    
                        
<li >
    <a href="../../internals/transforms/">Transformaitons</a>
</li>

                    
                        
<li >
    <a href="../../internals/testing/">Testing</a>
</li>

                    
                        
<li >
    <a href="../../internals/newfeature/">Adding a Language Feature</a>
</li>

                    
                    </ul>
                </li>
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                <li >
                    <a rel="next" href="../density/">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </li>
                <li >
                    <a rel="prev" href="../mh/">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
                <li>
                    <a href="https://github.com/hakaru-dev/hakaru">
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#hakaru-maple">Hakaru-Maple</a></li>
        
            <li><a href="#subcommands">Subcommands</a></li>
        
            <li><a href="#examples">Examples</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<h1 id="hakaru-maple">Hakaru-Maple</h1>
<p>Hakaru uses the computer algebra system Maple to aid in performing program
transformations. You can use this functionality of Hakaru if you have Maple
installed locally or can access Maple remotely. </p>
<p>Maple can be accessed through the module <code>Language.Hakaru.Maple</code> or through the
Hakaru program <code>hk-maple</code>.</p>
<p>The <code>hk-maple</code> command invokes a Maple command on a Hakaru program. Given a
Hakaru program in concrete syntax and a Maple-Hakaru command, typecheck the
program invoke the Maple command on the program and its type pretty print, parse
and typecheck the program resulting from Maple. See the <code>--help</code> flag of
<code>hk-maple</code> for more information.</p>
<p>The currently available Maple-Hakaru commands (also called subcommands):</p>
<ul>
<li>Simplify </li>
<li>Disintegrate </li>
<li>Summarize </li>
</ul>
<p>Note: calls to Maple may take a very long time. To see if your program is taking
an appreciable amount of time to parse and typecheck, use the <code>--debug</code> flag.</p>
<h2 id="subcommands">Subcommands</h2>
<h3 id="simplify">Simplify</h3>
<p>Hakaru programs are interpreted by Maple as linear operators. In this
interpretation, many commonly understood (by Maple) and powerful tools for
simplification become available. The metric for simplification as understood by
this command is sampling efficiency. <code>Simplify</code> attempts to be as conservative
as possible in changing the given program. In particular, it should not change
terms unless an improvement with respect to sampling is performed; in this case,
arbitrary rearrangement may happen, even if an expression more similair to the
original could be produced.</p>
<p><code>Simplify</code> is the default subcommand.</p>
<p><code>Simplify</code> preserves the semantics of the given program up to normalization of
weights. If the stronger sense of equivalence is needed, the output of
<code>Simplify</code> can be passed to <code>normalize</code>. </p>
<p>Historical note: the <code>Simplify</code> subcommand of <code>hk-maple</code> used to be known as a
seperate command named <code>simplify</code>. If you encounter <code>simplify someprog.hk
&lt;options&gt;</code> in this documentation, you may replace it by <code>hk-maple someprog.hk
&lt;options&gt;</code>.</p>
<h3 id="disintegrate">Disintegrate</h3>
<p>The Maple disintegrator is an alternative implementation of the program
transformation described in <a href="../../transforms/disintegrate">Disintegrate</a>. Semantically, the Maple
disintegrator and Haskell disintegrator implement the same transformation. In
particular, their outputs are not (often) identical, but have equivalent
sampling semantics. In practice, the ouputs may differ, since one may fail where
the other succeeds. </p>
<p>If in doubt about which disintegrator to use, consider the following order:</p>
<ol>
<li><code>disintegrate x</code></li>
<li><code>disintegrate x | hk-maple -</code></li>
<li><code>hk-maple --command disintegrate x</code></li>
<li><code>hk-maple x | disintegrate -</code> </li>
<li>etc&hellip;</li>
</ol>
<p>All of the above programs should be equivalent as samplers. </p>
<p>The disintegrator internally relies heavily on the <code>Simplify</code> command, so if the
given problem is an easy disintegration problem but a difficult simplification
problem, it is preferred to use the Haskell disintegrator followed by a call
to <code>Simplify</code>.</p>
<p>The chance that the Maple disintegrator produces a good program (or any program
at all) is proportional to the type of program it is given. In addition to
programs whose disintegration by Haskell is not efficient as a sampler, the
following programs are good candidates:</p>
<ul>
<li>programs which contain superpositions with complicated conditions</li>
<li>programs which contain complicated rational polynomials </li>
</ul>
<p>The Maple disintegrator follows the same conventions as the Haskell
disintegrator.</p>
<p>Like <code>Simplify</code>, <code>Disintegrate</code> preserves the semantics of the given program only up to
normalization of weights.</p>
<h3 id="summarize">Summarize</h3>
<p>Recall that our simplifier generates sampler code such as</p>
<pre><code class="nohighlight">    fn as array(prob):
     fn z array(nat):
      fn t array(real):
       fn docUpdate nat:
        array zNew of size(as):
         ... (summate _b from 0 to size(as):
               ... (summate i from 0 to size(t):
                     if _b == (if i == docUpdate: zNew else: z[i]):
                      t[i]
                     else: 0) ...) ...
</code></pre>

<p>(that&rsquo;s from <code>examples/gmm_gibbs.hk</code>) and</p>
<pre><code class="nohighlight">    fn topic_prior array(prob):
     fn word_prior array(prob):
      fn z array(nat):
       fn w array(nat):
        fn doc array(nat):
         fn docUpdate nat:
          ... (array zNew of size(topic_prior):
                product k from 0 to size(topic_prior):
                 product i from 0 to size(word_prior):
                  ... (summate j from 0 to size(w):
                        if doc[j] == docUpdate:
                         if k == zNew &amp;&amp; i == w[j]: 1 else: 0
                        else: 0) ...) ...
</code></pre>

<p>(that&rsquo;s from <code>examples/naive_bayes_gibbs.hk</code>).  In this Hakaru code, <code>fn</code> makes
a function (whose argument type is explicit), and <code>array</code>, <code>summate</code>, and
<code>product</code> are looping constructs.  In particular, the innermost loops (<code>summate
i</code> and <code>summate j</code>) run many times due to the outer loops.  Furthermore, most
iterations of the innermost loops produce 0 and so don&rsquo;t contribute to the
result.  We can dramatically speed up this computation by precomputing a
&ldquo;summary&rdquo; outside the loops then replacing the innermost loop by an expression
that reuses the summary rather than looping.</p>
<p>To understand our current approach to this optimization, let&rsquo;s look at
a simpler example.  Suppose the innermost loop is merely</p>
<pre><code class="nohighlight">    summate i from 0 to size(t):
     if _b == z[i]: t[i] else: 0
</code></pre>

<p>where the free variable <code>_b</code> denotes a natural number known to be bounded
by <code>size(as)</code>.  This loop denotes a real number that depends on <code>_b</code> and the
arrays <code>z</code> and <code>t</code>.  It turns out that we can rewrite it to the equivalent
expression</p>
<pre><code class="nohighlight">    let summary = Bucket i from 0 to size(t):
                   Index _b = z[i] of size(as):
                    Add t[i]
    in summary[_b]
</code></pre>

<p>where the capitalized keywords are newly introduced to support this
optimization.  The variable <code>summary</code> is bound to an array whose size
is <code>size(as)</code> and whose element at each index <code>_b</code> is the sum of those <code>z[i]</code>
whose corresponding <code>t[i]</code> matches <code>_b</code>.  A good way to compute the summary
on sequential hardware is to initialize the summary to an all-zero
mutable array then</p>
<pre><code class="nohighlight">    for i from 0 to size(t):
     summary[z[i]] += t[i]
</code></pre>

<p>A good way to compute the summary on parallel hardware is to divide the
data among the cores and summarize each portion in parallel then sum
the summaries elementwise.  The <code>Bucket</code> construct just introduced can
carry out either of these implementation strategies, by accordingly
interpreting the sub-language of map-reduce loops that <code>Index</code> and <code>Add</code> are
part of.  (Hence realizing this optimization from end to end in Hakaru
calls for adding the capitalized constructs to the Hakaru grammar and
extending the code generator(s) to handle them.)</p>
<p>Out of context, the let-expression above seems like a waste because
it computes a summary then uses only one element of it.  But the
right-hand-side of the summary-binding does not contain <code>_b</code> free, only
<code>t</code> and <code>z</code> and <code>as</code>, because the occurrences of <code>i</code> and <code>_b</code> are not uses but
bindings.  So, as an instance of loop-invariant code motion, we can move
the let-binding out of the loop over <code>_b</code>, and reuse the same summary
across all iterations over <code>_b</code>.  This way, we cut time complexity by a
factor of <code>size(as)</code> (the number of iterations over <code>_b</code>).</p>
<p>To pave the way for loop-invariant code motion, the summary should
depend on as few inner-scoped variables as possible.  This goal is
illustrated by the very first example above (from <code>gmm_gibbs.hk</code>).
Following the footsteps of the let-expression above, the <code>summate i</code>
expression is equivalent to</p>
<pre><code class="nohighlight">    let summary = Bucket i from 0 to size(t):
                   Index _b = (if i == docUpdate: zNew else: z[i]) of size(as):
                    Add t[i]
    in summary[_b]
</code></pre>

<p>but this summary depends on zNew (and on docUpdate).  Our prototype
implementation of summarization finds a better rewrite:</p>
<pre><code class="nohighlight">    let summary = Bucket i from 0 to size(t):
                   Split i == docUpdate:
                    Fanout(Add t[i], Nop)
                   else:
                    Index _b = z[i] of size(as):
                     Add t[i]
    in (if _b == zNew: fst(fst(summary)) else: 0) + snd(summary)[_b]
</code></pre>

<p>The type of this summary is not <code>array(real)</code> but <code>pair(pair(real,unit),
array(real))</code>.  The <code>array(real)</code> summarizes those <code>i</code> that are not equal
to <code>docUpdate</code>, whereas the <code>pair(real,unit)</code> turns out to be equal to
<code>(t[docUpdate],())</code>.  The check <code>_b == zNew</code> is postponed until the body
of the let, so the summary does not depend on zNew and can be moved out
of the <code>array zNew</code> loop, reducing time complexity by another factor of
<code>size(as)</code>.</p>
<p>Another way to understand this optimization is that we use loop exchange
to move the innermost loop out, then sum sparse arrays inside.</p>
<p>At least for the examples above, it turns out to be not very difficult
to automate rewriting a summate loop into a let-expression of the form</p>
<pre><code class="nohighlight">    let summary = Bucket i...
    in ...summary...
</code></pre>

<p>whose body does not loop over <code>i</code>.  The automatic rewriting traverses the
body of the original loop, using a set of rewriting rules &ndash; one for
each of <code>Index</code>, <code>Add</code>, <code>Split</code>, <code>Fanout</code>, and <code>Nop</code> &ndash; that are easy to pretend
for expository purposes to have been derived by equational reasoning
from the monoidal denotational semantics of the newly introduced
constructs.  The trick is as usual to design the map-reduce sub-language
right.  The design notes below provide some details, couched somewhat in
Maple syntax.</p>
<p>The summarization optimization can be accessed with <code>hk-maple -c Summarize</code>,
which only calls <code>Summarize</code> on the input program, and with <code>summary</code>, which
calls <code>Summarize</code> as well as generating Haskell code corresponding to the
summarized program. The <code>summary</code> command has its own options regarding the
generation of Haskell code; see <code>summary --help</code> for details.</p>
<h4 id="the-language-of-mapreductions">The language of mapreductions:</h4>
<p>A mapreduction mr denotes a monoid along with a map from indices (i) to
  monoid elements (such as e being t[i]).  There is an implicit index &lsquo;i&rsquo;,
  allowed to appear in e and cond.</p>
<pre><code class="nohighlight">  mr ::= Fanout(mr,mr) | Index(n,o,e,mr) | Split(cond,mr,mr) | Nop() | Add(e)
</code></pre>

<ul>
<li>
<p><code>Nop()</code> denotes the trivial monoid along with the constant map.</p>
</li>
<li>
<p><code>Add(e)</code> denotes the monoid of numbers under addition,
    along with the map i-&gt;e.</p>
</li>
<li>
<p><code>Fanout(mr1,mr2)</code> and <code>Split(cond,mr1,mr2)</code> both denote the product monoid of
    the monoids denoted by <code>mr1</code> and by <code>mr2</code>.  But if the maps denoted by
    <code>mr1</code> and <code>mr2</code> are <code>map1</code> and <code>map2</code> then <code>Fanout(mr1,mr2)</code> denotes the map
    <code>i-&gt;[map1(i),map2(i)]</code> whereas <code>Split(cond,mr1,mr2)</code> denotes the map
    <code>i-&gt;piecewise(cond,[map1(i),identity],[identity,map2(i)])</code>.</p>
</li>
<li>
<p><code>Index(n,o,e,mr(o))</code> denotes the product monoid of the monoids denoted by
    <code>mr(0)..mr(n-1)</code>, along with a map that returns a tuple that is
    all identity except at <code>o = e</code>.</p>
</li>
</ul>
<p>Run-time helpers:</p>
<pre><code class="nohighlight">  Bucket(mr, i=rng) =
    summary := Init(mr);
    for iv=rng do Accum(i, iv, mr, summary) end do;
    return summary
</code></pre>

<pre><code class="nohighlight">  Init(Fanout(mr1, mr2))      = [Init(mr1), Init(mr2)]
  Init(Index(n, o, e, mr))    = [seq(Init(mr), o=0..n-1)]
  Init(Split(cond, mr1, mr2)) = [Init(mr1), Init(mr2)]
  Init(Nop())                 = []
  Init(Add(e))                = 0
</code></pre>

<pre><code class="nohighlight">  Accum(i, iv, Fanout(mr1, mr2), summary) =
    Accum(i, iv, mr1, summary[1]);
    Accum(i, iv, mr2, summary[2]);
  Accum(i, iv, Index(n, o, e, mr), summary) =
    ov := eval(e, i=iv);
    if o::nonnegint and o&lt;n then Accum(i, iv, mr, summary[ov+1]) end if;
  Accum(i, iv, Split(cond, mr1, mr2), summary) =
    if eval(cond, i=iv) then Accum(i, iv, mr1, summary[1])
                        else Accum(i, iv, mr2, summary[2]) end if;
  Accum(i, iv, Nop(), summary) = ;
  Accum(i, iv, Add(e), summary) = summary += eval(e, i=iv);
</code></pre>

<p>Specification:</p>
<pre><code class="nohighlight">  If [mr, f] = summarize(e, kb, i)
  then f(Bucket(mr, i=rng)) = sum(e, i=rng)
  and we try to make mr depend on as little as possible
</code></pre>

<p>Implementation:</p>
<pre><code class="nohighlight">  summarize(C[piecewise(cond,a,b)], kb, i) =
    [Fanout(mr1, mr2),
     summary -&gt; piecewise(cond, f1(summary[1]), f2(summary[2]))]
    where [mr1, f1] = summarize(C[a], kb, i)
          [mr2, f2] = summarize(C[b], kb, i)
    if not depends(cond, i)
</code></pre>

<p>Choose between the two rules below by outermosting the variables in
    <code>indets(e,name) minus {i}</code>  versus  <code>indets(cond,name) minus {i}</code></p>
<pre><code class="nohighlight">  summarize(piecewise(o=e,a,0), kb, i) =
    [Index(n, o, e, mr),
     summary -&gt; piecewise(o::nonnegint and o&lt;n, f(summary[o+1]), 0)]
    where [mr, f] = summarize(a, kb, i)
    if not depends(o, i) and kb entails o::nonnegint and o&lt;n

  summarize(C[piecewise(cond,a,b)], kb, i) =
    [Split(cond, mr1, mr2),
     summary -&gt; f1(summary[1]) + f2(summary[2])]
    where [mr1, f1] = summarize(C[a], kb, i)
          [mr2, f2] = summarize(C[b], kb, i)

  summarize(0, kb, i) = [Nop(), summary -&gt; 0]

  summarize(e, kb, i) = [Add(e), summary -&gt; summary]
</code></pre>

<h2 id="examples">Examples</h2>
<h3 id="simplify_1">Simplify</h3>
<p>This program takes in a value of type <code>prob</code> and returns a measure of type <code>real</code>:</p>
<pre><code class="nohighlight">fn a prob:
  x &lt;~ normal(a,1)
  y &lt;~ normal(x,1)
  z &lt;~ normal(y,1)
  return z
</code></pre>

<p>The returned value, <code>z</code>, is generated by passing the last value generated by the function, starting with the original function argument. This indicates that it might be 
reducible to a smaller program. Assuming that we named the program <code>simplify_before.hk</code>, we can call the <code>Simplify</code> transform by running:</p>
<pre><code class="bash">hk-maple simplify_before.hk
</code></pre>

<p><strong>Note:</strong> The output for <code>Simplify</code> will be printed in the console. You can easily save this program to a file by redirecting the output to a file by calling 
<code>hk-maple model1.hk &gt; model2.hk</code>. For this example, we will call our new program <code>simplify_after.hk</code>. </p>
<p>When you open our new program, <code>simplify_after.hk</code>, you will see that the original five-line program has been reduced to a single line:</p>
<pre><code class="nohighlight">fn a prob: normal(prob2real(a), sqrt(3))
</code></pre>

<h3 id="disintegrate_1">Disintegrate</h3>
<p>(TODO)</p>
<h3 id="summarize_1">Summarize</h3>
<p>These examples are given in Maple syntax as opposed to typical examples in Hakaru syntax. </p>
<p>First &ldquo;summate i&rdquo; in offshore under gmm_gibbs.hk</p>
<pre><code class="nohighlight">summarize(piecewise(_b=piecewise(i=docUpdate,zNew,z[i]),t[i],0), kb, i)
  =
  [Split(i=docUpdate, Fanout(Add(t[i]), Nop()),
                        Index(size(as), _b, z[i], Add(t[i]))),
     summary -&gt; piecewise(_b=zNew, summary[1][1], 0) + summary[2][_b+1]]

      Recursive call to summarize assuming i=docUpdate is true:
      summarize(piecewise(_b=zNew,t[i],0), kb, i)
      = [Fanout(Add(t[i]), Nop()), summary -&gt; piecewise(_b=zNew, summary[1], 0)]

      Recursive call to summarize assuming i=docUpdate is false:
      summarize(piecewise(_b=z[i],t[i],0), kb, i)
      = [Index(size(as), _b, z[i], Add(t[i])), summary -&gt; summary[_b+1]]

          summarize(t[i], kb, i)
          = [Add(t[i]), summary -&gt; summary]
</code></pre>

<p>First &ldquo;summate j&rdquo; in offshore under naive_bayes_gibbs.hk</p>
<pre><code class="nohighlight">  summarize(piecewise(doc[j]=docUpdate,piecewise(k=zNew,piecewise(i=w[j],1,0),0),0), kb, j)
  = [Fanout(Index(size(word_prior), i, w[j], Index(size(z), docUpdate, doc[j], Add(1))),
            Index(size(z), docUpdate, doc[j], Nop())),
     summary -&gt; piecewise(k=zNew, summary[1][w[j]+1][docUpdate+1]], 0)]

      Recursive call to summarize assuming k=zNew is true:
      summarize(piecewise(doc[j]=docUpdate,piecewise(i=w[j],1,0),0), kb, j)
      = [Index(size(word_prior), i, w[j], Index(size(z), docUpdate, doc[j], Add(1))),
         summary -&gt; summary[w[j]+1][docUpdate+1]]

          Recursive call to summarize assuming i=w[j]:
          summarize(piecewise(doc[j]=docUpdate,1,0), kb, j)
          = [Index(size(z), docUpdate, doc[j], Add(1)),
             summary -&gt; summary[docUpdate+1]]

      Recursive call to summarize assuming k=zNew is false:
      summarize(piecewise(doc[j]=docUpdate,0,0), kb, j)
      = [Index(size(z), docUpdate, doc[j], Nop()),
         summary -&gt; 0]
</code></pre></div>
        </div>

        <footer class="col-md-12">
            <hr>
            
            <center>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</center>
        </footer>

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script>
        <script>var base_url = '../..';</script>
        <script data-main="../../mkdocs/js/search.js" src="../../mkdocs/js/require.js"></script>
        <script src="../../js/base.js"></script>
        <script src="../../js/mathjaxhelper.js"></script>
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                        <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            From here you can search these documents. Enter
                            your search terms below.
                        </p>
                        <form role="form">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                            </div>
                        </form>
                        <div id="mkdocs-search-results"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>
    </body>
</html>